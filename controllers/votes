from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from models.solution import SolutionModel
from models.problem import ProblemModel
from serializers.vote import VoteCreateSchema,VoteSchema
from typing import List
from database import get_db
from models.user import UserModel
from dependencies.get_current_user import get_current_user

router = APIRouter()

@router.get("/problems/{problem_id}/solutions/{solution_id}/votes", response_model=List[VoteSchema])
def get_votes(problem_id: int,solution_id=int, db: Session = Depends(get_db)):
    solution = db.query(SolutionModel).filter(SolutionModel.id == solution_id).first()
    if not solution:
        raise HTTPException(status_code=404, detail="solution not found")
    return solution.votes

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

@router.get("/votes/{votes_id}", response_model=VoteSchema)
def get_votes(vote_id: int, db: Session = Depends(get_db)):
    vote = db.query(VoteSchema).filter(VoteSchema.id == vote_id).first()
    if not vote:
        raise HTTPException(status_code=404, detail="vote not found")
    return vote

@router.post("/problems/{problem_id}/solutions/{solution_id}/votes", response_model=SolutionSchema)
def create_solution(problem_id: int,solution_id:int, vote: VoteCreateSchema, db: Session = Depends(get_db),current_user: UserModel = Depends(get_current_user)):
    solution = db.query(SolutionModel).filter(SolutionModel.id == solution_id).first()
    if not solution:
        raise HTTPException(status_code=404, detail="solution not found")

    new_vote = VoteModel(**vote.dict(), vote_id=vote_id,user_id=current_user.id)
    db.add(new_vote)
    db.commit()
    db.refresh(new_vote)
    return new_vote

@router.put("/solutions/{solution_id}", response_model=SolutionSchema)
def update_solution(solution_id: int, solution: SolutionUpdateSchema, db: Session = Depends(get_db),current_user: UserModel = Depends(get_current_user)):
    db_solution = db.query(SolutionModel).filter(SolutionModel.id == solution_id).first()
    if not db_solution:
        raise HTTPException(status_code=404, detail="solution not found")

    solution_data = solution.dict(exclude_unset=True)
    for key, value in solution_data.items():
        setattr(db_solution, key, value)

    db.commit()
    db.refresh(db_solution)
    return db_solution

@router.delete("/solutions/{solution_id}")
def delete_solution(solution_id: int, db: Session = Depends(get_db),current_user: UserModel = Depends(get_current_user)):
    db_solution = db.query(SolutionModel).filter(SolutionModel.id == solution_id).first()
    if not db_solution:
        raise HTTPException(status_code=404, detail="solution not found")

    db.delete(db_solution)
    db.commit()
    return {"message": f"solution with ID {solution_id} has been deleted"}